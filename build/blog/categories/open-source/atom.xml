<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: open source | Danger Cove]]></title>
  <link href="http://www.dangercove.com/blog/categories/open-source/atom.xml" rel="self"/>
  <link href="http://www.dangercove.com/"/>
  <updated>2015-08-24T11:27:56+02:00</updated>
  <id>http://www.dangercove.com/</id>
  <author>
    <name><![CDATA[Danger Cove]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Easily add acknowledgments to your Xcode projects]]></title>
    <link href="http://www.dangercove.com/blog/2014/05/29/easily-add-acknowledgments-to-your-xcode-projects/"/>
    <updated>2014-05-29T15:14:00+02:00</updated>
    <id>http://www.dangercove.com/blog/2014/05/29/easily-add-acknowledgments-to-your-xcode-projects</id>
    <content type="html"><![CDATA[<p>When you're working on a iOS or OSX app, you're bound to use a library, framework or other code that was generously shared by other people. The right thing to do (especially when the license requires it!) is to acknowledge that you're using their work in your app.</p>

<p>There are various ways to go about this, but I've just released <a href="https://github.com/DangerCove/Acknowledge/">a script called Acknowledge</a> that will make it very easy. It also works very well with <a href="https://github.com/DangerCove/DCOAboutWindow">DCOAboutWindow</a>, which I released earlier.</p>

<div class="thumbnail">
<a href="https://github.com/DangerCove/Acknowledge/"><img src="/images/content/acknowledge-acknowledgments.jpg" title="Acknowledgments" alt="Acknowledgments"></a>
</div>




<!-- more -->


<p>Acknowledge is a simple bash script that will easily generate a rtf that contains all the acknowledgments for libraries, frameworks and other code you've used in your iOS or OSX project.</p>

<p>It's made to work very well with <a href="https://github.com/DangerCove/DCOAboutWindow">DCOAboutWindow</a> and <a href="http://www.cocoapods.org">Cocoapods</a>. Acknowledge relies on <a href="http://fletcherpenney.net/multimarkdown">MultiMarkdown by Fletcher Penny</a>.</p>

<p>You can <a href="https://github.com/DangerCove/Acknowledge/">read more about Acknowledge on GitHub</a>, or follow the setup guide below.</p>

<h2>Clone</h2>

<p>Clone the repo, preferably into the root of your Xcode project:</p>

<pre><code>$ git clone git@github.com:DangerCove/Acknowledge.git
</code></pre>

<p>Or if your project is a repo already, add it as a submodule:</p>

<pre><code>$ git submodule add git@github.com:DangerCove/Acknowledge.git
</code></pre>

<h3>Install multimarkdown</h3>

<p>Follow <a href="http://fletcherpenney.net/multimarkdown/install">the guide</a> on Fletcher's website, or if you're using homebrew:</p>

<pre><code>$ brew install multimarkdown
</code></pre>

<h3>Configure</h3>

<p>Copy acknowledge.cfg.default to acknowledge.cfg:</p>

<pre><code>$ cd Acknowledge
$ cp acknowledge.cfg.default acknowledge.cfg
</code></pre>

<p>Customize the paths to multimarkdown and your Pods folder if necessary.</p>

<h3>Add acknowledgments</h3>

<p>If you use Cocoapods and have your Pods directory setup, you are ready to go. Just run <code>acknowledge</code>.</p>

<pre><code>$ ./acknowledge
</code></pre>

<h4>Other acknowledgments</h4>

<p>Just add a markdown file to the <code>sources</code> directory and Acknowledge will handle the rest. Make sure the extension is <code>.md</code>.</p>

<h4>Order</h4>

<p>You might've notice the <code>10_</code> and <code>20_</code> prefixes in front of the files in the <code>sources</code> folder. Acknowledge will concatenate the files in order, so just add files and change to number to change the order.</p>

<p>The acknowledgments generated by Cocoapods will always be prepended with <code>10_</code>.</p>

<h3>Potential directory layout</h3>

<pre><code>.
|- Acknowledge/
|   |- acknowledge
|   |- ...
|   |- source/
|   |   |- 11_Vendor.md
|   |   |- 20_Acknowledge.md
|- Pods/
|   |- Pods-acknowledgements.markdown
|-  |- ...
|- Podfile
|- Coolproject.xcodeproj
|- Coolproject.xcworkspace
|- ...
</code></pre>

<h3>Test it</h3>

<p>Don't skip this step, you'll need to output in the next one.</p>

<p>Open a terminal window and run <code>acknowledge</code> once to see if it works, and to generate the initial <code>Acknowledgments.rtf</code>.</p>

<pre><code>$ ./acknowledge
</code></pre>

<p>Fix any errors and proceed.</p>

<h3>Add it to Xcode</h3>

<p>You'll probably want to show the acknowledgments somewhere in your app (have a look at <a href="https://github.com/DangerCove/DCOAboutWindow">DCOAboutWindow</a> if you're working on a Mac app, btw).</p>

<p>Simply add the generated <code>Acknowledgments.rtf</code> file to your project and display it somewhere.</p>

<h4>Generate the acknowledgments on each build</h4>

<p>Keeping your acknowledgments up to date is easy if you add Acknowledge as a build phase. Here's how that works:</p>

<ol>
<li>Open Xcode;</li>
<li>Select your project and open the <code>Build Phases</code> tab;</li>
<li>Click <code>Editor → Add Build Phase → Add Run Script Build Phase</code>;</li>
<li>Name your script something like "Update Acknowledgments" and position it so that it's above <code>Copy Bundle Resources</code>;</li>
<li>Now add the following code:</li>
</ol>


<p><code>cd Acknowledge &amp;&amp; ./acknowledge</code></p>

<p>(Make sure to adapt the paths if the script isn't located in the default folder.)</p>

<p>It should look something like this:</p>

<div class="thumbnail">
<img src="/images/content/acknowledge-buildphase.jpg" title="Acknowledge Build Phase" alt="Acknowledge Build Phase">
</div>


<p>That's it! Just build your project and you're set.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Grab content from a web browser in your Mac app]]></title>
    <link href="http://www.dangercove.com/blog/2014/01/27/grab-content-from-a-web-browser-in-your-mac-app/"/>
    <updated>2014-01-27T15:43:00+01:00</updated>
    <id>http://www.dangercove.com/blog/2014/01/27/grab-content-from-a-web-browser-in-your-mac-app</id>
    <content type="html"><![CDATA[<p>One of my favorite features of <a href="http://www.dangercove.com/tapetrap">Tapetrap</a> is its ability to subscribe to a website while surfing the web with your browser. Instead of looking for the RSS feed manually and copy-pasting the link, you can click a button and Tapetrap will find and add the feed for you. In this article I want to go over why I think that's awesome and how it works. The source code for the URL grabbing is <a href="https://github.com/DangerCove/DCOURLGrabber">available on GitHub</a>.</p>

<div class="thumbnail">
<iframe width="620" height="349" src="http://www.dangercove.com//www.youtube.com/embed/zzoGEhWTXRw?rel=0&amp;vq=hd720" allowfullscreen></iframe>
<div class="caption">
Adding feeds from your web browser in Tapetrap
</div>
</div>




<!-- more -->


<h2>Not a browser plugin</h2>

<p>I've <a href="https://chrome.google.com/webstore/detail/treasure-chest-radio-3fm/geeoeokcenpaehoemkfdjfmnobopefck">made</a> and use a few browser extensions. They're neat little applications that take an insane amount of work to maintain. While some code can be shared you will need to tailer parts of the extension for each browser specifically.</p>

<p>For Tapetrap, I chose to make a system wide browser extension in the form of an icon in the menu bar that "just works" with the active web browser when clicked. This means users don't have to install anything extra and I don't have to create a plugin per browser. I can't say I'm the first one to do something like this, but it works particularly well for Tapetrap.</p>

<div class="thumbnail">
<img src="/images/content/tapetrap-ss-menubar.jpg" title="Add Feeds While Surfing the Web" alt="Add Feeds While Surfing the Web">
</div>


<p>Of course there are downsides to using this approach too. It's impossible to manipulate the DOM inside the browser or execute other more context aware methods. It's fine for getting basic information, though.</p>

<h2>How grabbing works</h2>

<p>This is where it gets a little technical. I combined a basic menu bar app with my own URL grabber code, called <a href="https://github.com/DangerCove/DCOURLGrabber">DCOURLGrabber</a>, to get the URL from the web browser that was last active.</p>

<p>I'll skip the menu bar icon part. There are plenty of <a href="http://kmikael.com/2013/07/01/simple-menu-bar-apps-for-os-x/">good tutorial</a>s that explain all you need. Instead I'll talk about how to interact with the web browser.</p>

<h3>AppleScript</h3>

<p>Yep, AppleScript. Often used to automate tedious tasks, it's also a great way to interface with other applications. For DCOURLGrabber I focussed on getting the URL from the selected tab of the key window of the web browser that was last active. This is the AppleScript for getting the URL in Google Chrome:</p>

<p><code>applescript Grab URL From Chrome https://github.com/DangerCove/DCOURLGrabber/raw/master/AppleScripts/com.google.Chrome.scpt
tell application "Google Chrome"
  get URL of active tab of first window
end tell
</code></p>

<p>Simple enough right? For <a href="https://github.com/DangerCove/DCOURLGrabber/tree/master/AppleScripts">Safari and Opera</a> the command are very similar. The one for Firefox is a little longer.</p>

<p><code>applescript Grab URL From Firefox https://github.com/DangerCove/DCOURLGrabber/raw/master/AppleScripts/org.mozilla.firefox.scpt
tell application "Firefox" to activate
tell application "System Events"
  keystroke "l" using command down
  keystroke "c" using command down
end tell
delay 0.5
the clipboard
</code></p>

<p>Hopefully they'll switch to a straightforward approach in a future update. In any case, after running these scripts they present the current URL of the browser window.</p>

<h3>Objective-C</h3>

<p>To run this in Objective-C, create a new Mac project in XCode, paste in the next piece of code in the <code>applicationDidFinishLaunching:</code> method and that's it.</p>

<p>``` objective-c Get URL From Chrome in Objective-C
// The script to run. You could also load this from a file as in DCOURLGrabber
NSString *chromeScript =
@"tell application \"Google Chrome\"\n"
"  get URL of active tab of first window\n"
"end tell";</p>

<p>// Load the script
NSAppleScript *script = [[NSAppleScript alloc] initWithSource:chromeScript];</p>

<p>// Grab URL using AppleScript
NSDictionary <em>scriptExecuteError;
NSAppleEventDescriptor </em>result = [script executeAndReturnError:&amp;scriptExecuteError];
if(scriptExecuteError) {</p>

<p>  // Failed
  NSLog(@"Error: %@", scriptExecuteError);</p>

<p>} else {</p>

<p>  NSLog(@"Output: %@", result.stringValue);</p>

<p>}
```</p>

<p>Using DCOURLGrabber it becomes even easier. Check the <a href="https://github.com/DangerCove/DCOURLGrabber">GitHub page</a> for more documentation.</p>

<p>``` objective-c Get URL From Chrome in Objective-C Using DCOURLGrabber
DCOURLGrabber <em>grabber = [[DCOURLGrabber alloc] init];
NSURL </em>url = [grabber grabURLFromBundleID:@"com.google.Chrome" withError:&amp;grabError];
if(grabError) {</p>

<pre><code>NSLog(@"Failed to retrieve URL: %@", grabError);
</code></pre>

<p>} else {</p>

<pre><code>NSLog(@"Got URL: %@", url.absoluteString);
</code></pre>

<p>}
```</p>

<h2>Getting the RSS/Atom URL</h2>

<p>Websites that value their feeds will link to it from their website. Not only with the well-known orange button, but also through a meta tag in the source code of the website. This gives apps like Tapetrap a way of retrieving it.</p>

<p>The GameKings website has this setup correctly. Inspecting the source of <a href="http://gamekings.tv">http://gamekings.tv</a> reveals the following lines near the top of the document.</p>

<p><code>
&lt;link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="http://www.gamekings.tv/feed/" /&gt;
&lt;link rel="alternate" type="text/xml" title="RSS .92" href="http://www.gamekings.tv/feed/rss/" /&gt;
&lt;link rel="alternate" type="application/atom+xml" title="Atom 1.0" href="http://www.gamekings.tv/feed/atom/" /&gt;
&lt;link rel="alternate" type="application/rss+xml" title="Gamekings Video's RSS Feed" href="http://www.gamekings.tv/rss?cat=3"&gt;
&lt;link rel="alternate" type="application/rss+xml" title="Gamekings Nieuws RSS Feed" href="http://www.gamekings.tv/rss?cat=18"&gt;
</code></p>

<p>All links point to RSS feeds. There are some similarities between the lines. Using these conventions, it's easy to extract them in code. Even easier with <a href="https://github.com/tracy-e/OCGumbo">OCGumbo</a>, which is a HTML5 parser. It converts RSS into Objective-C objects.</p>

<p>The following lines of code parse a simple HTML page, check the 'type' parameter of the 'link' meta tag for either application/rss+xml, application/atom+xml, rss+xml or atom+xml and log the link when it matches.</p>

<p>``` objective-c Log the Link to a RSS Feed Found in the Head
// Create an array that contains the strings that can appear in the 'type' property
NSArray *linkTypeFeedIndicators = [NSArray arrayWithObjects:@"application/rss+xml", @"application/atom+xml", @"rss+xml", @"atom+xml", nil];</p>

<p>NSString *htmlString =
@"<html><head>"
"<link rel='alternate' type='application/rss+xml' title='RSS 2.0' href='http://www.gamekings.tv/feed/' />"
"</head><body>"
"<h1>Feed discovery experiment</h1>"
"<p>Just testing ;).</p>"
"</body></html>";</p>

<p>// Load the document from a string containing HTML
OCGumboDocument <em>document = [[OCGumboDocument alloc] initWithHTMLString:htmlString];
OCGumboElement </em>root = document.rootElement;</p>

<p>// Loop through all 'link' tags
[root.Query(@"link") enumerateObjectsUsingBlock:<sup>(OCGumboElement</sup> <em>element, NSUInteger idx, BOOL </em>stop) {</p>

<pre><code>NSString *type = [element.attr(@"type") stringByRemovingNewLinesAndWhitespace];

// Check if the type is equal to that of a RSS/Atom feed
if([linkTypeFeedIndicators containsObject:type]) {
    NSString *feedURLString = element.attr(@"href");
    NSLog(@"Found a feed: %@", feedURLString);
}
</code></pre>

<p>}];
```</p>

<p>With the URL of the RSS feed in hand, the road is clear to analyze its content using a RSS parser, or maybe use the URL for something different entirely.</p>

<h2>Real world example</h2>

<p>You can <a href="http://www.dangercove.com/tapetrap">download Tapetrap</a> to get a feel of how this works. The app is now in public beta and free to use. Also let me know what you think and help improve it!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Glow for updates]]></title>
    <link href="http://www.dangercove.com/blog/2013/10/23/glow-for-updates/"/>
    <updated>2013-10-23T17:17:00+02:00</updated>
    <id>http://www.dangercove.com/blog/2013/10/23/glow-for-updates</id>
    <content type="html"><![CDATA[<p>Everybody knows software updates. A window pops up to notify you an update is available,
you accept and a few seconds later you have new features (and less bugs, hopefully).</p>

<p>Automatic software updates are great and generally make everybody's lives
better. As a developer I can be sure most of my customers are using the latest
version. As a user you press a single button to update, instead of going to
the website, downloading a new package and overwriting the previous version.</p>

<p>All Danger Cove apps (except the ones on the App Store) use <a href="http://sparkle.andymatuschak.org/">Sparkle</a>
for automatic updates. Sparkle checks a feed every day and lets you know when a
new version is available. Getting that feed online is what I want to talk about
today.</p>

<!-- more -->


<p>Previously I manually edited these feeds and manually wrote the <a href="http://update.getporthole.com/release_notes/?source=article">release
notes</a> in a text
editor. Knowing that I have to look up version numbers, file sizes and sign the
update (for security, nobody should be able to release an update in my name).
This can take some time.</p>

<p>That's why I've made <a href="https://github.com/DangerCove/Glow">Glow</a> and if you're a
software developer, it might come in handy for you as well. That's why I've
released it on GitHub. Here's my description of it.</p>

<blockquote><p>Glow is a tool that generates Sparkle-compatible Appcast update feeds and html release notes for your Mac projects. It's not a full blown, database driven, multiple project supporting, update releasing laser canon. Rather it's a clean, easy to use script that will automate 90% of releasing updates to your users.</p></blockquote>

<p>The <a href="https://github.com/DangerCove/Glow">GitHub page</a> contains a very detailed
walkthrough on how to get started.</p>

<p>Automating the process of creating these updates leaves more time to work on
fixing bugs and adding cool new features. Also, I might have some more time to
style those release notes :).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Alfred 2 Workflow for Reign]]></title>
    <link href="http://www.dangercove.com/blog/2013/08/11/alfred-2-workflow-for-reign/"/>
    <updated>2013-08-11T14:55:00+02:00</updated>
    <id>http://www.dangercove.com/blog/2013/08/11/alfred-2-workflow-for-reign</id>
    <content type="html"><![CDATA[<div class="thumbnail">
<img src="/images/adventures/reign/screenshots/alfred.jpg" title="Alfred 2 Workflow for Reign" alt="Alfred 2 Workflow for Reign">
</div>


<p>For those of you that are familiar with <a href="http://www.alfredapp.com/" target="_blank">Alfred</a>,
you probably need no explanation as to why a workflow for <a href="/reign">Reign</a> will come in
pretty handy. Read on to learn what it does.</p>

<div class="text-center">
<a href="https://raw.github.com/DangerCove/reign-alfred2-workflow/master/Reign%20for%20Spotify.alfredworkflow" class="btn btn-large btn-success">Download the
Alfred 2 Workflow for Reign</a>
</div>




<!-- more -->


<blockquote><p>Alfred saves you time when you search for files online or on your Mac. Be more productive with hotkeys, keywords and file actions at your fingertips.</p></blockquote>

<p>That's what it says on Alfred's website. It basically moves a lot of control to
your keyboard, so you can keep your eyes on the task at hand. For Reign this
means that you can remote control Spotify running on another Mac by simply
entering simple commands, like <code>reign n</code> to skip a track or <code>reign o</code>
to open the track that's currently playing in your own Spotify client, so you
can star or share it.</p>

<p>It reduces the need to visit the web interface and makes remote controlling
Spotify even faster and easier!</p>

<p>Of course, like Reign, the workflow is open-source and free to share. <a href="https://github.com/DangerCove/reign-alfred2-workflow">Visit
the GitHub project</a> to contribute and read more about how it works. Or
just <a href="https://raw.github.com/DangerCove/reign-alfred2-workflow/master/Reign%20for%20Spotify.alfredworkflow">download the workflow file</a>
to get started.</p>

<p>Reign is available on the Mac App Store, for free.</p>

<div class="text-center">
<a href="https://itunes.apple.com/app/coucou/id620436774"><img src="/images/MacAppStore_download.png" title="Available on the Mac App Store" alt="Available on the Mac App Store"></a>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Distractless]]></title>
    <link href="http://www.dangercove.com/blog/2012/11/11/distractless/"/>
    <updated>2012-11-11T18:19:00+01:00</updated>
    <id>http://www.dangercove.com/blog/2012/11/11/distractless</id>
    <content type="html"><![CDATA[<div class="thumbnail">
<img src="/images/content/distractless.jpg" title="Distractless" alt="Distractless">
</div>


<p>HTML5 local storage and fullscreen API experiment. Distraction free writing in your browser: <a href="http://distractless.herokuapp.com" target="_blank">distractless.herokuapp.com</a>.</p>
]]></content>
  </entry>
  
</feed>
